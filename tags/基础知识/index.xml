<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础知识 on Jalins 博客</title>
    <link>https://jalins.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
    <description>Recent content in 基础知识 on Jalins 博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 28 May 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jalins.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>区块链100篇之第九篇  默克尔树</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B9%9D%E7%AF%87-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</link>
      <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B9%9D%E7%AF%87-%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91/</guid>
      <description>区块链100篇之第九篇&amp;ndash;默克尔树（Merkle Tree） 中本聪在他的创世论文中一个概念，就是SPV，中文意思是简单支付验证，从这里我们可以看出SPV指的是“支付验证”而不是“交易验证”，那这两者有什么区别吗？简单的说就是支付验证只需验证该笔交易是否被确认过了，而交易验证是需要验证该笔交易是否满足一些条件如“余额”是否足够，还有该笔交易有没有存在双花等等一些问题，只有一切都没什么问题后该笔交易才算验证通过，可以看出交易验证要比支付验证更加复杂，所以它一般是由挖矿节点来完成的，而支付验证只要普通的轻钱包就可以完成。那现在有一个问题了，SPV是如何实现的？答案就是默克尔树，也就是今天要讲的主题，理解了默克尔树之后在回过头来就能理解SPV了。
 什么是Merkle Tree？
 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成，看下图： 来简单讲一下这幅图，我们从最底部开始看，D0、D1、D2和D3是叶子节点包含的数据，也就是叶子节点的value，继续往上看，N0、N1、N2和N3是就是叶子节点，它是将数据（也就是D0、D1、D2和D3）进行hash运算后得到的hash值；继续往上看，N4和N5是中间节点，它们各是N0和N1经过hash运算得到的哈希值以及N2和N3经过hash运算得到的哈希值，注意，它们是把相邻的两个叶子结点合并成一个字符串，然后运算这个字符串的哈希；接着往上，Root节点是N4和N5经过hash运算后得到的哈希值，这就是这颗默克尔树的根哈希。
分析到这里我们大概可以知道在默克尔树中最下面的大量的叶节点包含基础数据；每个中间节点是它的两个叶子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。
还有从默克尔树的结构可以看出，任意一个叶子节点的交易被修改，叶子节点hash值就会变更，最终根节点的hash值就会改变。所以确定的根节点的hash值可以准确的作为一组交易的唯一摘要。
现在可以总结一下默克尔树的特点： 1.首先是它的树的结构，默克尔树常见的结构是二叉树，但它也可以是多叉树，它具有树结构的全部特点。
2.默克尔树的基础数据不是固定的，想存什么数据由你说了算，因为它只要数据经过哈希运算得到的hash值。
3.默克尔树是从下往上逐层计算的，就是说每个中间节点是根据相邻的两个叶子节点组合计算得出的，而根节点是根据两个中间节点组合计算得出的，所以叶子节点是基础。
 如何通过Merkle树验证一笔交易？
 大概了解了什么是默克尔树后，可能会有一个疑问，就是默克尔树是如何验证一笔交易的？也就是我们上文提到的SPV（支付验证）。看下面一幅图:
假设我们要验证区块中存在Hash值为9Dog:64（绿色框）的交易，我们仅需要知道1FXq:18、ec20、8f74（黄色框）即可计算出781a、5c71与Root节点（藕粉色框）的哈希，如果最终计算得到的Root节点哈希与区块头中记录的哈希（6c0a）一致，即代表该交易在区块中存在。这是因为我上文提到的两个点，一个是默克尔树是从下往上逐层计算的，所以只要知道相邻的另一个节点的hash值就可以一直往上计算直到根节点，另一个是根节点的hash值可以准确的作为一组交易的唯一摘要，依据这两点就可以来验证一笔交易是否存在。
 比特币中的默克尔树
 介绍完默克尔树的基本知识，我们来看一下比特币中的默克尔树长什么样，看下面一幅图： 可以看到区块头包含了根节点的hash值，而中间节点、叶子节点还有基础数据在放在了区块体中。
这里有一点需要提的就是在比特网络中的Merkle树是二叉树，所以它需要偶数个叶子节点。如果仅有奇数个交易需要归纳，那最后的交易就会被复制一份以构成偶数个叶子节点，这种偶数个叶子节点的树也被称为平衡树。
 默克尔树的典型应用场景
 默克尔树的应用场景其实很广泛，比较典型的就是P2P下载。在点对点网络中作数据传输的时候，会同时从多个机器上下载数据，而且很多机器可以认为是不稳定或者不可信的。为了校验数据的完整性，更好的办法是把大的文件分割成小的数据块（例如，把分割成2K为单位的数据块）。这样的好处是，如果小块数据在传输过程中损坏了，那么只要重新下载这一快数据就行了，不用重新下载整个文件。
怎么确定小的数据块没有损坏哪？只需要为每个数据块做Hash。BT下载的时候，在下载到真正数据之前，我们会先下载一个Hash列表。那么问题又来了，怎么确定这个Hash列表本事是正确的哪？答案是把每个小块数据的Hash值拼到一起，然后对这个长字符串在作一次Hash运算，这样就得到Hash列表的根Hash。下载数据的时候，首先从可信的数据源得到正确的根Hash，就可以用它来校验Hash列表了，然后通过校验后的Hash列表校验数据块。
除了P2P下载外，默克尔树还可以被用来快速比较大量的数据，因为当两个默克尔树根相同时，则意味着所代表的数据必然相同。还有就是可以用来实现零知识证明（零知识证明指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。举个例子，你要我向你证明我拥有某一把钥匙，这个时候我不需要直接拿钥匙给你看，而是用这个钥匙开锁拿出所在柜子中的某一样东西给你看以此来证明我拥有这把钥匙），关于零知识证明以后有时间再讲，ZCash就是采用零知识证明来达到交易匿名的目的，有兴趣可以去查找资料。</description>
    </item>
    
    <item>
      <title>区块链100篇之第八篇  智能合约</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%85%AB%E7%AF%87-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</link>
      <pubDate>Mon, 30 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%85%AB%E7%AF%87-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</guid>
      <description>区块链100篇之第八篇&amp;ndash;智能合约  一、比特币的转账过程
 我在第五篇讲UTXO的时候，有提到比特币的转账过程，现在来回顾一下这个过程。 &amp;gt; * Bob想要转给Jack一百个比特币，Bob需要先创建一笔交易，因为这笔交易只有被矿工验证并打包进区块的时候才算完成交易，Bob在填写交易信息的时候除了需要提供支付比特币的数额以及双方的地址外，还需要提供自己的公钥以及用私钥生成的数字签名，还有就是上一笔交易的Hash（也就是Bob从哪里得到这些比特币）；信息填完后（其实在现实中没这么复杂，只需要在钱包中填写转入转出地址以及交易金额即可，其他的都是自动的）便可以点击确认，当这笔交易广播到全网中时，矿工开始对这笔交易进行验证，第一步会去找到上一笔交易，确认支付方的比特币来源；接着第二步算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实；然后第三步是使用公钥去解开数字签名，保证私钥属实。验证通过后矿工便会将这笔交易打包进区块中，如果得到六次以上的确认，则可以认为这笔交易不会再被改变。
讲这个过程就是为了引出今天的知识点&amp;ndash;智能合约。
 二、比特币与智能合约
 在上面我有讲到Bob需要提供的交易信息有一个是上一笔的交易Hash，我们可以来看一下区块链中时如何记录这笔交易的（这其实就是一个UTXO），如下图所示： 可以看出Bob转给Jack的100个比特币是从Alice那得到的，图中还可以看到一个解锁信息，这个解锁信息时候用来证明这100个比特币的归属，因为只有Bob的私钥才能进行解锁，其他人进行解锁是无效的。 到这里我们可以将这个UTXO看做是一个简单的智能合约，因为它是一个可自动执行并且自我验证协议，Bob只要输入自己的私钥，解锁脚本就会自动运行校验，解锁成功便说明Bob是这100个比特币的拥有者，反之则说明不是。 因为比特币所支持的脚本语言只跟交易有关，并且不是图灵完备的语言，所能做的事很有限，但是比特币的出现极大地促进了智能合约的发展，现在支持编写智能合约的平台中最有名的当属以太坊。
 三、智能合约
 上世纪90年代，密码学家尼克萨博从自动贩卖机得到灵感首次提出“智能合约”的概念，看一下智能合约的定义：
  智能合约是指一种计算机协议，这类协议一旦制定和部署成功就能实现自我执行（self-executing）和自我验证（self-verifying），而且不再需要人为的干预。   智能合约会对接收到的信息进行回应，它可以接收和储存价值，也可以向外发送信息和价值。看一张图： 从图中可以看出一段代码（智能合约），被部署在分享的、复制的账本上，它可以维持自己的状态，控制自己的资产和对接收到的外界信息或者资产进行回应。 举个例子，现在我们对银行账户内存款的操作都需要中心化的银行进行授权，一旦离开了银行的监管，用户就连最基本的存取款操作都无法进行，但是如果是使用智能合约来处理的话情况就不一样了，只要事先正确的通过严谨的逻辑写好代码，便可以不需要人工参与，一切都将按事先写好的逻辑运行，并且结果是公平公正的，因此也有人宣称“代码即法律”，这个观点保留意见，至少以目前的情况来看事情没那么简单。 智能合约的概念虽然很早就被提出来了，但是因为很多技术的不成熟，所以发展很缓慢，但是因为比特币的出现或者说因为区块链技术的出现，智能合约开始成为研究人员与业内人士重点研究的对象，这都极大促进了智能合约的发展。
 四、智能合约的优缺点
 参考《区块链技术指南》简单列出智能合约的优点。
  首先是高效的实时更新，因为智能合约的执行是去中心化的，也就是不需要认为的干预，所以它的执行效率是很高的，你不再需要亲自去相关部门提交排队提交申请资料，然后还需要等几个工作日才能得到结果，现在只需要在网上填好资料点击提交，如果网络通畅，几分钟内便能办完手续，方便快捷。 第二便是较低的人为干预风险，因为智能合约是一开始就制定好的，并且是无法更改的，所以一旦出现毁约的情况，那么时间的责任人就会得到相应的惩罚，这保证了公平公正性，也就是说在智能合约面前，人人平等，没有谁有特权。 第三就是准确运行， 智能合约是一段执行在计算机上的代码，所以只要运行的计算机没错县错误，那么这个合约的执行结果都是准确无误的，不会出现不可预料的情况，之所以能做到这一点也是得益于密码学的发展和区块链技术的发明。 第四是去中心化权威，在区块链网络中一般不存在一个绝对的权威来监督合约的执行，而是由绝大部分的用户来判断合约是否正常执行，这种绝大多数人监督的方式是由POW或POS等共识机制来实现的。 第五便是较低的运行成本，正因为智能合约具有去人为干预的特点，其能够大大减少合约履行、裁决和强制执行所产生的人力成本。   关于智能合约的缺点，我讲一下我的理解，因为智能合约的一段可执行的代码，是代码便不可避免的会存在bug，一旦出现bug或者不可预料的情况，这对于采用智能合约的应用都是极大的挑战（可以参考The DAO事件），这是因为智能合约是去人工干预的。智能合约的优点目前也是它的缺点，但是随着技术的发展，它的这个缺点或许可以被忽略。 &amp;gt; 五、以太坊与智能合约
说到智能合约就不能不讲到以太坊，与比特币相比，以太坊最大的不同点是它可以支持更加强大的脚本语言（图灵完备的脚本语言），允许开发者在上面开发任意应用，实现任意智能合约，这也是以太坊的最强大之处。作为平台，以太坊可以类比于苹果的应用商店，任何开发者都可以在上面开发应用，并出售给用户。以太坊也是目前支持智能合约的区块链平台中比较成熟的平台。</description>
    </item>
    
    <item>
      <title>区块链100篇之第七篇--比特币的分叉</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%83%E7%AF%87-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%88%86%E5%8F%89/</link>
      <pubDate>Tue, 24 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%83%E7%AF%87-%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E5%88%86%E5%8F%89/</guid>
      <description>区块链100篇之第七篇&amp;ndash;比特币的分叉 1.遵循相同机制的分叉 我在第六篇讲到了一种情况就是在比特币网络中，在某一时刻有两个矿工同时算出随机数（即获得记账权），那么这个时候便会出现一种情况，即一条主链叉开变成两条叉链，每条链沿着各自的方向延伸下去，如下图所示： 之所以会出现这种情况是因为每个矿工在开始挖新的区块之前都会先把上一个区块复制过来，然后接上这个区块进行下一个区块的挖矿工作。而现在在全网中的同一时刻有两个符合条件的区块，那么由于距离的远近（P2P网络），矿工找到的区块是不一样的（虽然这两个区块都是符合条件的区块），所以有一些矿工会拿到橙色的区块进行下面的挖矿工作，而有一些矿工会拿到蓝色的区块进行挖矿工作，这就势必导致上图所示的情况，这种情况叫分叉。 对于此类情况，比特币有一个很好的机制，就是上文提到的短链服从长链，那么为了达到这种效果比特币是如何做的呢？ 首先区块是由矿工挖出来的，矿工进行挖矿就需要矿机（以后会专门讲矿机），而不同的矿机具有不同的算力（每秒运算多少次），也就是说每个矿工的计算能力是不一样的，那么，就会出现一种情况，即两条链中会有一条链的算力要比另一条链大，因此这条链的增长速度就会比另一条链要快，也就是这条链会比另一条链长。这时你可能会说那如果两条链的算力一直保持一样呢？这种情况是不可能会出现的，在短时间内是可能的，但一段时间后这种平衡势必会被打破，比如有新的矿机出来（新的矿机算力一般都比较高），那么就会有矿工去购买来替换旧的矿机，这就会导致算力不平衡。 但其中一条链超过另外一条链时，这时全网中就会出现一条最长链，那么矿工在进行新的打包区块工作的时候会把最长链全部复制过来，再在这条链的基础上继续挖矿，当所有矿工都这样做的时候那么这条链就会成为一条主链，而另外一条链就会被抛弃掉，如下图所示： 到这里可能会有一个疑问，就是如果矿工执意要在那条短链上进行挖矿呢？如果这个矿工聪明一点的话他就知道这么做是吃力不讨好的，因为一旦他所在的链最后没有成为主链的话，他在这条连上挖到的比特币都会归零，他之前所做的工作都白费的，所以一般不会去做这种事。 好了，到这里或许能明白比特币是如何保证系统中账本唯一性的了，但是需要注意的是这里所有的矿工都是遵循相同的机制，比如每条链的每个区块都是1M大小。那么如果一条链1M大小一条链是8M大小呢？比特币系统还会不会同样的保留最长链丢弃短链呢？继续往下看。
2.遵循不同机制的分叉 如果是遵循不同的机制也会出现分叉，一般分为软分叉和硬分叉。 &amp;gt; * 1.软分叉
软分叉好理解一点，就是当系统进行升级时（比如比特币将一个区块的大小从1M扩容到8M），有一些矿工还没来得及升级，那么就会出现一条链是1M的，一条链是8M。这种情况也好解决，只需要这部分矿工进行升级就行了，那么那条1M的链就会自动消失，而且对全网没有任何的影响。 这里可以把软分叉理解为一个人换了一件新的衣服，人还是那个人，只是样子看起来变了。
  2.硬分叉   当整个区块链网络中，系统版本或协议升级后，且和老版本协议不兼容，未升级的老节点无法接受新节点挖出的全部或者部分区块，导致出现了两条链，假设新节点的算力较大，新节点们在维护一条链，老节点也始终在维护一条他认可的链，如果这时候大多数的节点都开始升级为新版本，那么老节点维护的链能不能存活就看算力有多少了，这就称作硬分叉。直白点就是一条链真的分叉成两条链，且这两条链互不兼容，是两条独立的主链，这两条链唯一的联系就是在分叉前的数据都是一样，而分叉后全都不一样，举个例子就是一块地基上原来有了一座旧房子，这时在这块地基上重新建另一座房子，建成后两者除了在同一块地基上之外就没有任何联系了。 关于硬分叉最有名的当属以太坊的The DAO事件，感兴趣的可以自行查资料，这件事导致了以太坊分叉形成两条不同的主链，一条是以太坊（ETH），一条是以太经典（ETC），现在两条链都同时存在。</description>
    </item>
    
    <item>
      <title>区块链100篇之第六篇--共识机制</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Wed, 18 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</guid>
      <description>区块链100篇之第六篇&amp;ndash;共识机制  共识
 共识的英文是Consensus，也可以翻译成一致或一致同意。维基百科对于共识的定义是：共识是指分歧双方搁置争议，达成能够被各方所接受的陈述（即使有时只是勉强接受）的社群解决方案。简单的说就是在一个群体中就某一个问题达成共识，一致同意采取某一种策略来解决这个问题，举个例子：
 现在有一个班级，大家需要就什么时候拍毕业照进行投票，有两个方案，方案一是在5月1号拍毕业照，方案二是在论文答辩后拍，这时大家进行投票决定，假设结果大多数人选择了方案一，那么最终大家就需要无条件服从这个决定。这里什么时候拍毕业照是一个问题，而在决定五月初拍这是解决这个问题的一个策略，到这里对应上面共识的定义就大概能明白是什么是共识了。
 这里有一点要注意的就是并不是全部的人都选择方案一，那么为什么最终结果是选择方案一而不是方案二呢，这是因为大家在此之前就已经达成了另一个共识，就是“少数服从多数”，也就是说我们是在已经有了一个共识的前提下达成另一个共识。
 共识机制
 上面的共识应该很容易理解，讲完共识，我们来了解什么是共识机制，共识机制又称共识算法，看一下是维基百科对共识机制的解释：
  由于加密货币多数采用去中心化的区块链设计，节点是各处分散且平行的，所以必须设计一套制度，来维护系统的运作顺序与公平性，统一区块链的版本，并奖励提供资源维护区块链的使用者，以及惩罚恶意的危害者。这样的制度，必须依赖某种方式来证明，是由谁取得了一个区块链的打包权（或称记账权），并且可以获取打包这一个区块的奖励；又或者是谁意图进行危害，就会获得一定的惩罚，这就是共识机制。   用自己的话说就是如何在彼此都不信任的基础（因为会存在有人捣乱的情况）上仍然可以就某一个问题达成一致。为了一步步的讲解，先来看下面的一张图：
这张图我们暂且称左边的人为A，右边的人为B，那么思考一个问题，假如在一开始的时候他们彼此都不认识（彼此不信任），那么他们能否就自己带的是什么颜色的帽子这个达成共识（不能自己摘下自己的帽子来看）？ 从这张图我们可以确定一下几点： &amp;gt; * A知道B的帽子是什么颜色的； &amp;gt; * B知道A知道他的帽子是什么颜色的； &amp;gt; * A也知道B知道自己知道他的帽子是什么颜色的； &amp;gt; * &amp;hellip;&amp;hellip;
A其实没办法验证自己的帽子是什么颜色的，你可能会说那A可以直接问B自己是什么颜色的帽子呀，这样不就达成共识了吗，没错，A确实可以通过询问的方式来知道自己帽子的颜色，但是我上面说了他们彼此是不信任的，假如B告诉A他的帽子是绿色的，那么A得到的结论永远都是错的，所以A是永远都不能证实自己的帽子是什么颜色的。这个其实是两个将军问题的翻版，两个将军问题已经被证实是无解的。 我们继续这个问题往下思考，你可能会想那能不能多添加几个人，通过询问其他人自己的帽子是什么颜色的，然后以少数服从多数的原则就可以初步证实自己的帽子是什么颜色的（注意这里是初步证实不是完全证实，后面会讲为什么），那么有出现一个问题，至少需要添加多少人才能满足可以进行判断的要求？如果是增加一个比如C，那么如果C告诉A他的帽子颜色是黄色的（为了简单，就先假设现在只有黄、绿两个选择），A还是无法证实自己的帽子是什么颜色的，因为他根本就不知道他们中谁在说谎；那么增加两个人呢，比如增加C、D，这个时候他们三个人中就可能会有两个人的答案是一致的，那么A就可以基本知道自己的帽子是什么颜色了。到这里你可能还会问，那如果有两个人说谎呢？这样A得到的结果还是错误的（这就是我上面为什么说是初步而不是完全证实，就是这个原因）。那这个问题要如何解决？先不急我们先捋一捋。
  共识机制的本质是解决信任的问题，就是在彼此都不信任的基础上达成一致的意见； 在分布式系统（或者区块链）中要达成共识至少需要四个节点以上，少于四个节点是无法达成共识的。    拜占庭将军问题
 在上面我提到就是如果有两个人都说谎了那该如何解决？问题的答案是解决不了，结果就是A会一直被蒙在鼓里，其实提这个问题是为了引出另一个问题，即拜占庭将军问题，看下面的故事：
 拜占庭帝国想要进攻一个强大的敌人，为此派出了10支军队去包围这个敌人。这个敌人虽不比拜占庭帝国，但也足以抵御5支常规拜占庭军队的同时袭击。这10支军队在分开的包围状态下同时攻击。他们任一支军队单独进攻都毫无胜算，除非有至少6支军队（一半以上）同时袭击才能攻下敌国。他们分散在敌国的四周，依靠通信兵骑马相互通信来协商进攻意向及进攻时间。困扰这些将军的问题是，他们不确定他们中是否有叛徒，叛徒可能擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭将军们才能保证有多于6支军队在同一时间一起发起进攻，从而赢取战斗？
 为了简化问题，我们先假设所有的将军是通过口头消息来传递信息的，即消息传递的信道绝无问题，因为如果还要考虑信息在传递的过程中被人修改了这种情况，那问题就要更加复杂了，这里先不讨论这个，后面打算单独写一篇关于拜占庭将军问题，再来详细讲解。
  问题分析   单从上面的说明可能无法理解这个问题的复杂性，我们来简单分析一下：
先看在没有叛徒情况下，假如一个将军A提一个进攻提议（如：明日下午1点进攻，你愿意加入吗？）由通信兵通信分别告诉其他的将军，如果幸运中的幸运，他收到了其他6位将军以上的同意，发起进攻。如果不幸，其他的将军也在此时发出不同的进攻提议（如：明日下午2点、3点进攻，你愿意加入吗？），由于时间上的差异，不同的将军收到（并认可）的进攻提议可能是不一样的，这是可能出现A提议有3个支持者，B提议有4个支持者，C提议有2个支持者等等。
再加一点复杂性，在有叛徒情况下，一个叛徒会向不同的将军发出不同的进攻提议（通知A明日下午1点进攻，通知B明日下午2点进攻等等），一个叛徒也会可能同意多个进攻提议（即同意下午1点进攻又同意下午2点进攻）。
叛徒发送前后不一致的进攻提议，被称为“拜占庭错误”，而能够处理拜占庭错误的这种容错性称为（Byzantine fault tolerance），简称为BFT。
到这里大概能理解拜占庭将军问题是讲什么的了，对于这个问题如果现在有n个将军和m个叛徒，只要满足n&amp;gt;=3m+1就能达成共识（注意前提是口头消息）。比如有2/3的成员是诚实的，算法就能达到共识。如果叛徒多于1/3，无法达到共识，这些军队无法协调他们的攻击，敌军胜利。
所以当一个分布式系统中有多余三分之一节点出现了故障时，那对这个系统是毁灭性的，当然这些是理论，现实不一定就是毁灭性的，但是一定是很糟糕的事情。
 区块链的共识算法
 因为区块链是一个分布式的系统，所以它一定存在拜占庭将军问题，那么就需要解决如何保证各个主机状态一致的问题，为了解决这个问题很多人都提出了自己的共识算法，最有名的当属中本聪的POW（工作量证明机制）共识算法，当然还有POS（权益证明机制）、DPOS（股权权益证明机制）、PBFT（拜占庭容错机制）以及RAFT共识算法，对于这些算法在后面都会一一讲到，这里就不讲了，今天主要是理解什么是共识机制以及在区块链中共识机制所要解决的问题。
 结尾
 在本篇最开始的时候我提到了少数服从多数这个共识，其实在比特币中对应的就是选择最长链，会出现这个问题是因为矿工在打包区块的时候会出现一种情况，即有两个矿工同一时刻计算出随机数获得记账权，这个时候就会出现两条链，这两条链会沿着不同的方向发展下去，那么结果就是比特币网络会变得越来越混乱，为了防止这种事情发生，比特币有一个原则就是选择最长链，即在某一时间段内比较哪条链最长（因为算力的不同就会出现在一段时间后总有一条链的长度超过另一条链的长度这种情况），然后把短的链丢弃掉，这其实也是少数服从多数的原则，准确的说应该是短链服从长链。</description>
    </item>
    
    <item>
      <title>区块链100篇之第五篇--UTXO</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87-utxo/</link>
      <pubDate>Sat, 14 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%BA%94%E7%AF%87-utxo/</guid>
      <description>区块链100篇之第五篇&amp;ndash;UTXO 第一次看到UTXO是去年10月份的时候在一个微信群上有一个人说了一句话，说：”只要理解了UTXO就理解了比特币“，虽然这话有点夸大了，毕竟比特币并不只有UTXO这个技术，涉及到的东西还是很多的，但可以把这句话改成”只要理解了UTXO就能理解比特币的去中心化的含义“，因为UTXO区别于我们传统上的交易都是基于账户模型的，它是中本聪发明的交易模型，暂且叫UTXO模型，理解了UTXO的交易模型就能明白为什么比特币是去中性化的。
 什么是UTXO？
 UTXO的全称叫Unspent Transaction Output，因为外国人习惯把Translation叫做TX，所以就简称为UTXO，中文翻译过来就是“未消费的交易输出”，从字面上的意思可以从两点入手来理解，第一是：未消费；第二是：输出。 未消费就是还没有花出去的，这就好比你现在手上有一张十块跟一张五块，这时候你去吃个饭花了十块，那么你手上就只剩五块了，而这五块就是未消费的。 什么是输出？刚开始看到这两个字时可能会有些疑问，输出意味着拿出去，也就是花出去，那都花出去了怎么能叫未消费呢？按正常的逻辑确实讲不通，但可以换个思路。既然有输出那自然对应的就会有输入，那什么是输入呢？输入就是交易时的给那笔钱，举个例子，本来你打算只吃十块钱的饭，但是你发现只要再加两块钱就可以多加一个鸡腿，于是你改变主意想吃十二块的饭，这时你手里只有一张十块的跟一张五块的，没有两张一块的，于是你就拿着十块跟五块给老板。这里的十块跟五块就是你跟老板之间的交易的输入，然后老板就把饭打给你，接着还找了三张一块钱的给你，这里的三张一块钱便是输出，而且这三张一块钱你还没有花出去，也就是“未消费”，那么就可以把这三张一块钱称为“UTXO”。 这里可以给UTXO下个简单的定义：UTXO = 一笔交易的总输入 - 在这笔交易中花费了多少钱（包括手续费）。为什么说是简单的定义，因为UTXO也有可能是挖矿得到的，比如中本聪挖的第一个区块（也就是创世区块）得到的50个比特币，这50比特币就是UTXO，所以说我刚才的定义并不准确，我下的定义是排除了挖矿这种情况，只在正常的交易过程中适用。到这里你可能会有些疑问，第一，你付给老板的那十二块算不算UTXO？这个问题需要单独写一篇才能说明白，也就是比特币的找零机制，留到第十篇讲，这里先说一下为什么不能简单的说那十二块是不是UTXO，在概念层面上，答案是肯定的，因为这十二块就是“未消费的输出”，但是在实际上我们并不能将你付给老板的那一张十块跟一张五块拆开来，你不能把那张五块钱撕成两半，一半代表两块钱一半代表三块钱，这个在现实世界里是做不到的，但是在比特币的世界里却是很轻松，这个之后再详细讲；第二，既然UTXO可以作为交易的输入，那么交易完成后这个UTXO如何处理，答案是销毁，一旦交易被确认并记录到比特币的区块中，那么这个UTXO就会被永久的销毁掉。
 比特币是如何通过UTXO实现交易的？
 大概明白了什么是UTXO，那么就来讲讲UTXO的交易过程是怎样的。为了理解我们可以举个现实交易的例子，现在我要转一百块钱到你的账户去，基本的过程是这样的，银行会先检查我的账户里的余额有没有大于等于一百块，如果有那么就会将我的账户减去100，接着会在你的账户上增加一百，这个过程看起来很容易理解，因为银行确实就是这么干的，但是这里要注意的就是在你我之间存在着一个中心机构，它帮我们进行账户的验证以及转账的操作，但是在比特币的世界里是没有中心机构的，那么它是如何做到即使没有中心机构依然可以让交易顺利的进行？ 假设我现在手里总共有十个比特币，这个十个比特币可能是很多个UTXO组成的，比如0.1BTC，0.5BTC，3BTC，0.0123BTC，6.18BTC，0.2077BTC，这些UTXO总共加起来有10个BTC，这个时候我想转3.55个BTC给你，那么这个时候交易的输入就是0.1BTC，0.5BTC，3BTC，而交易输出就是3.55BTC跟0.05BTC，其中3.55BTC这个UTXO会使用你的公钥进行“锁定”，而0.05BTC的UTXO会使用我的公钥进行“锁定”（这里涉及到非对称加密，可以看我的第二篇博客），一旦被脚本锁定就说明这个比特币是属于谁的，因为只有拥有公钥对应的私钥的人才能进行解锁。到这里我的账户上的比特币总量是6.45个比特币，分别是0.0123BTC，6.18BTC，0.2077BTC跟0.05BTC，注意到没，这里我账户“余额”并不是6.45BTC，而是被我（所有者）锁住的、分散的UTXO，在比特币世界里并没有所谓的“余额”，只有UTXO，我们平常所说的比特币“余额”多少，是通过扫描区块链并聚合所有属于该用户的UTXO来计算该用户的余额。注意到这里你我之间并没有任何的第三方介入，纯粹就是我们两人之间的交易而已，这边是去中心化。
 UTXO有什么优点？
 看完上面可能会云里雾里，你可能会说这不就跟我们现实生活中给钱差不多嘛，假如现在我有五张一块钱的，现在我需要给你两块钱，我直接把两张一块钱的给你就行了，这其中也不需要什么人来介入，我们两个人就可以搞定这笔交易。 确实是这样，但是区别就在于UTXO是可分割的，假如现在你要我给你两块五而不是两块，但我现在并没有五毛，我没办法将一块钱撕成两半，所以这笔交易在现实中就比较难达成，但是UTXO就不一样了，它可以切割到小数点后八位，比如可以有0.00023546BTC，所以基本可以满足大部分的交易需求，可以这么说，UTXO使得比特币既解决了传统现金不可分割的问题也避免了传统电子货币的中心化弊端，是去中心化的电子现金。</description>
    </item>
    
    <item>
      <title>区块链100篇之第四篇--矿工及挖矿</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87-%E7%9F%BF%E5%B7%A5%E5%8F%8A%E6%8C%96%E7%9F%BF/</link>
      <pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E5%9B%9B%E7%AF%87-%E7%9F%BF%E5%B7%A5%E5%8F%8A%E6%8C%96%E7%9F%BF/</guid>
      <description>区块链100篇之第四篇&amp;ndash;矿工及挖矿 在第二篇中我遗留了一个问题，就是虽然收款人没办法验证付款人是否真的有足够的余额进行支付转账（因为现在没有一个中心机构进行认证），所以这时候就需要矿工来进行确认，对于为什么需要矿工这个角色和矿工是干什么的以及挖矿的过程，下面就来一一细说。
 为什么需要矿工？
 比特币是一个点对点去中心化的网络，在这个网络里任何人都可以参与进来，成为这个网络中的节点（普通节点或者矿工节点），正因为比特币的世界中没有一个中心机构来确保比特币整个系统的正常运行（这与我们现在中心化系统不一样，是比特币的一大魅力），那么如何确保比特币正常运行呢？这就需要矿工了。
 矿工是干什么的？
 因为比特币的交易需要进行确认，并需要将多笔交易打包成区块，矿工便是干这个的。矿工接收到用户广播的账单后，要对账单的合法性和真实性进行验证，这里的合法性，是指矿工会检验支付方的比特币是否充足。矿工们按照交易中支付方的地址，在过往合法的交易中查询该账户“转入”的比特币数量，当大于或者等于本账单中填写的数额时，这笔交易就是合法的，这回答了我们一开头的那个问题；接着矿工需要开始用不同的随机数进行哈希计算，直至找到符合目标值特征的随机数，如果找到了这个随机数，矿工需要将在 10 分钟左右发生的验证过的交易内容打包成一个不超过1MB大小的区块，然后全网广播出去，告诉其他矿工节点已经生成一个新的区块了，你们不需要再进行随机数的计算了，于是其他矿工就会进行验证这个随机数是否是正确的，如果通过了验那么这个新区块就会被添加到最长链的尾部（为什么说最长链，这里涉及到比特币的分叉，在第七篇讲），然后他们就会放弃当前区块的计算，马上继续下一个区块的随机数计算。
举个例子就是现在我和小明、小花、小白以及小李进行记账竞赛（谁赢了谁就有糖吃，所以都很努力的记账），我们都把每一笔有效的交易记录在一个本子上，因为我们的记账速度都差不多，所以我们几乎是同时把本子上的一页纸（相当于一个区块）写满，这个时候并不能以谁记账速度快来分胜负（因为大家几乎同时完成记账），所以我们还需要进行计算一道数学方程题，谁先接触这道题谁就可以获得糖果；于是大家开始埋头计算数学题，假设这时小明最先解除了答案，于是他就大喊一声，“我解出来”，这时大家就开始停下手上的计算工作，开始验证小明的答案是否就是这道题的解，结果大家都认为小明解出了答案，于是这颗糖（比特币）便属于小明的了。
 挖矿的过程
 挖矿的过程其实就类似于解题，谁先找到答案谁就获得记账权，从而获得比特币奖励。 挖矿的具体过程为：参与者根据上一个区块的hash值，10分钟内的验证过的交易内容，再加上自己猜测的一个随机数X，让新区块的hash值小于比特币网络中给定的一个数。这个数越小，计算出来就越难。系统每隔两周（即经过2016个区块）会根据上一周期的挖矿时间来调整挖矿难度（通过调整限制数的大小），来调节生成区块的时间稳定在10分钟左右。为了避免震荡，每次调整的最大幅度为 4 倍。
 比特币如何保证矿工积极挖矿？
 我在第一篇讲比特币的时候有简单提到过比特币的奖励机制，比特币的激励机制就是奖励矿工一些比特币用来激励矿工积极的记账以此来达到整个系统稳定运行的效果，所以矿工节点就需要不断的提高自己的算力来争夺打包区块的权力，因为你的算力越大你就有可能先计算出符合某一个标准的比特币区块头的哈希散列值，这就是工作量证明共识机制，简称POW，除了POW外还有POS、DPOS、RAFT等等（这个留到第六篇讲共识机制的时候再说）。比特币是通过工作量证明的共识机制来决定记账权的，通俗来讲，谁证明了自己的工作量最大，谁就负责记账。 矿工除了可以得到比特币网络奖励的比特币，还可以获得每一笔交易的手续费，奖励手续费可以保证当所有的比特币发行完毕后（总量2100万，预计到2140年发完）比特币网络仍然可以正常运行。</description>
    </item>
    
    <item>
      <title>区块链100篇之第三篇--数字签名</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%89%E7%AF%87-%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</guid>
      <description>区块链100篇之第三篇&amp;ndash;数字签名 数字签名类似于我们现实世界中的文件签名，我们把名字写在一个文件上，就代表了我们认可了这份文件，并且说明了这份文件是真是可靠的，那么问题是如果文件的署名被伪造了怎么办？在现实世界中，我们一般会找当事人直接验证这份文件是否是亲自签署的而不是被人假冒的，而在计算机世界中，保证数字签名不被伪造是通过数字摘要和非对称加密实现的，举个比特币中交易的例子:假如现在Alice发起一笔比特币转账，需要先将该交易进行数字摘要，缩短成一段字符串，然后用自己的私钥对摘要进行加密，形成数字签名。完成后，需要将交易信息（使用接收者的公钥进行加密）和数字签名一起广播给记录“账本的人”也就是矿工。矿工用Alice的公钥进行验证，如果验证成功，说明该笔交易确实是Alice发出的，且信息未被更改，是完整的。 下面就来详细讲解这数字摘要和非对称加密技术，讲完之后再回过头来看这个例子就明白了。
 数字摘要
 数字摘要技术用于对所要传输的数据进行运算生成信息摘要，它并不是一种加密机制，但却能产生信息的数字&amp;rdquo;指纹&amp;rdquo;，它的目的是为了确保数据没有被修改或变化，保证信息的完整性不被破坏。说直白点就是将数据进行hash编码。它在数字签名中的作用就是增加被伪造的难度，就好比有些人故意把字要写的龙凤凤舞，目的就是很难让他人伪造。
 非对称加密
 讲到非对称加密我们需要了解一下什么是对称加密，举个例子：现在你（未成年）跟你朋友想聊一个比较敏感的话题（比如&amp;hellip;），但是你怕你老妈会翻看你手机，要是让她知道你跟别人聊这种话题肯定会挨骂，于是你就跟你的朋友约定好你将中文先翻译成英文再发过去，然后他那边可以使用微信翻译将英文翻译成中文，这样即使老妈看到了也无所谓，因为她根本看不懂英语，于是你跟你的朋友便聊了起来：
  你：The XiaoHua in the class are so beautiful that I want to chase her.（班里的小花好漂亮，我想追她） 你朋友：I also think she&amp;rsquo;s pretty.（我也觉得她好漂亮） &amp;hellip;&amp;hellip;   这里的“班里的小花好漂亮，我想追她”就是明文，而“The XiaoHua in the class are so beautiful that I want to chase her.”就是密文，而密钥就是将“班里的小花好漂亮，我想追她”转化成“The XiaoHua in the class are so beautiful that I want to chase her.”这么一个规则，讲到这大概就清楚了什么是对称加密了吧，可以这么理解： &amp;gt; * 一方通过密钥将信息加密后，把密文传给另一方，另一方通过这个相同的密钥将密文解密，转换成可以理解的明文。他们之间的关系： 明文 &amp;lt;-&amp;gt; 密钥 &amp;lt;-&amp;gt; 密文</description>
    </item>
    
    <item>
      <title>区块链100篇之第二篇--P2P与比特币的支付与交易</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%BA%8C%E7%AF%87-p2p%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E6%94%AF%E4%BB%98%E4%B8%8E%E4%BA%A4%E6%98%93/</link>
      <pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%BA%8C%E7%AF%87-p2p%E4%B8%8E%E6%AF%94%E7%89%B9%E5%B8%81%E7%9A%84%E6%94%AF%E4%BB%98%E4%B8%8E%E4%BA%A4%E6%98%93/</guid>
      <description>区块链100篇之第二篇&amp;ndash;P2P与比特币的支付与交易 因为比特币网络是一个点对点的网络，也就是peer-to-peer，简称P2P，所以这里需要先讲一下P2P的知识，讲这个主要是更好的理解比特币的支付与交易的过程。
 P2P
 P2P网络是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点，每个网络节点以扁平（flat）的拓扑结构相互连通。对比中心化网络，在P2P网络中不存在任何服务端（server）、中央化的服务。 那么问题来了，节点是如何发现其他节点的呢？ &amp;gt; * 1.节点会记住它最近成功连接的网络节点，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。
  2.节点会在失去已有连接时尝试发现新节点。
 3.当建立一个或多个连接后，节点将一条包含自身IP地址消息发送给其相邻节点。相邻节点再将此消息依次转发给它们各自的相邻节点，从而保证节点信息被多个节点所接收、保证连接更稳定。
 4.新接入的节点可以向它的相邻节点发送获取地址getaddr消息，要求它们返回其已知对等节点的IP地址列表。节点可以找到需连接到的对等节点。
 5.在节点启动时，可以给节点指定一个正活跃节点IP,如果没有，客户端也维持一个列表，列出了那些长期稳定运行的节点。这样的节点也被称为种子节点（其实和BT下载的种子文件道理是一样的），就可以通过种子节点来快速发现网络中的其他节点。
   上面的话可能有点难理解，举个生动的例子就是假设你和A是好闺蜜（建立过连接，对应第一点），现在你的一个男性朋友想追A，他想知道关于A的一些信息，这时他可以通过你来得到A的信息（新节点接入，对应第四点），那么这个时候A会把自己的信息告诉你，而你就会将这个信息告诉给你的男性朋友（对应第三点）；如果此时你跟A吵架闹掰了，那么你可能会尝试找新的朋友（对应第二点），至于第五点可以理解为假如你现在有了男朋友，那么你每天醒来的时候第一个想见的可能就是你的男朋友，但如果没有男朋友的话，那么这个时候你的清单里会罗列一些你的“备胎”。这个是对上面那五个点的理解，主要P2P的本质就是节点与节点是平等的。
 比特币的支付与交易
 讲完了P2P的知识，现在来讲一下比特币的支付与交易过程。 传统上我们进行支付的过程是这样的：A（填写收款人的银行卡账号及转账金额） &amp;ndash;&amp;gt; C（银行，验证A的信息是否正确及账户上余额是否充足，如果条件满足则将A上的账户余额减去相应的额度，并将B的余额增加相应的额度） &amp;ndash;&amp;gt; B（B的账户上多了A转过来的钱），但是在比特币网络中是没有C这个节点的，也就是说没有中间机构来验证A的信息是否正确，余额是否充足，那么是如何做到每一笔交易是真是可靠的呢？
  1.首先是付款人签署交易单   付款人需要输入自己的比特币地址以及收款方的比特币地址，还要输入转账比特币的个数，如5个比特币，然后付款方会发送一个请求给收款方（以P2P的形式发送），在发送这个请求之前付款人会先加上收款人的公钥（这里可以先理解为地址，但是两者是有区别的）和交易信息，然后再用自己的私钥加密整个请求，并把自己的公钥标记在这个请求上。这里需要注意的是付款人不仅要将这个请求发给收款方，还需要以P2P的方式广播出去告诉其他网络节点，让所有节点都接收到这个请求。 举个例子Alice要给Bob转账5个比特币，那么Alice首先要询问Bob的标识字符串（比特币地址），例如是“ABCDEFG”，同时Alice也有一个标识字符串例如是“HIJKLMN”，然后Alice写一张单子，内容为“HILKLMN支付5比特币给ABCDEFG”，然后用自己的保密印章（私钥）盖一个章，将这张单子交给Bob。 这个过程涉及到非对称加密和数字摘要的知识，在下一篇会详细讲解，看完就会知道为什么要这么做。
  2.接着是收款人确认单据签署人   收款人收到这个请求后拿着付款人的公钥进行解密，如果能解密则说明付款人确实是拥有这个私钥的，进而说明这笔账是从付款人转过来的，还可以得到收款人的公钥（因为上面已经讲了付款人会将收款人的公钥跟交易信息进行加密）说明这笔账确实是转给收款人的。
  3.确认付款人余额   通过上面的步骤是可以确定这笔账确实是付款人发起的，但是没办法有效的确认付款人是否真的有足够的余额进行转账（毕竟现在没有一个中心机构进行认证），所以这个时候就需要矿工（第四篇会讲）来进行确认，这是因为在比特币的世界里是没有余额这个概念的，我们在比特币钱包里看到的“余额”不是我们所理解的余额，它其实是UTXO（意思是未花费的交易输出，这个打算在第五篇讲），验证付款方是否有余额这个工作通常由矿工来做，而收款方不需要做这个工作，只需要验证这个请求是否是付款人发起的即可。</description>
    </item>
    
    <item>
      <title>区块链100篇之第一篇--序（比特币）</title>
      <link>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%BA%8F%E6%AF%94%E7%89%B9%E5%B8%81/</link>
      <pubDate>Wed, 04 Apr 2018 13:09:11 +0800</pubDate>
      
      <guid>https://jalins.github.io/2018/%E5%8C%BA%E5%9D%97%E9%93%BE100%E7%AF%87%E4%B9%8B%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%BA%8F%E6%AF%94%E7%89%B9%E5%B8%81/</guid>
      <description> 区块链100篇之第一篇&amp;ndash;序（比特币） 这是区块链100篇的第一篇，自己接触区块链已经有七个月左右了，是去年的九月份才开始接触区块链这个词，一开始以为区块链是一个很高深的技术领域（它的确涉及到了很多高深的知识如密码学、分布式网络、计算机软件、博弈论等等），不过好在这些底层的技术已经有人帮我们封装了，如以太坊，所以入门的门槛就降低了。打算写这个区块链100篇的初衷只是想把自己学到的知识输出出来，顺便让自己从头捋一遍，这样有助于自己对区块链的更深入理解。还有写这个系列的灵感来源于火币出品的区块链100问，个人觉得做得挺好的，所以想用同样的方式来记录自己学区块链的点点滴滴。以后每个星期会更新两到三篇，工作忙的话就只能保证更新一篇，整个系列目标是写到一百篇，主要分三大块，比特币、以太坊以及超级账本（后面或许会加上EOS，这个看情况）。
  Bitcoin（比特币） Ethereum（以太坊） Hyperledger Fabric（超级账本） EOS（可能不会更新）   说到区块链就绕不开比特币，毕竟是先有比特币再有区块链的，所以这个系列就从比特币开始说起，后面会对比特币涉及到的各种知识进行逐一讲解（个人能力有限，所以知识点可能会讲错）。
比特币与区块链的历史 2008年11月，一个化名中本聪的人发表了一篇名为《比特币：点对点的电子现金系统》的论文，这也被俗称为创世论文，2009年1月用他第一版的软件挖出了第一个区块，即创世区块，之后越来越多的人开始加入挖比特币的行列，一开始参与的人大部分是一些极客，他们对这个数字货币充满好奇，并坚信比特币会颠覆世界金融，随着比特币的影响力越来越大，更多的人加入进来，这其中就不乏一些大神级别的人物，如V神。到了2014年，V神创立了以太坊，正式提出区块链这个概念，到2016年这个概念才开始为公众所知，2017年由于ICO热炒而成为媒体热点，现在依然火热。
比特币的运行机制 简单讲完比特币与区块链的历史（详细的历史可以自行上网查找，这里就不赘述），下面我们讲个故事特币的运行机制，之后的会对这其中涉及到的各个知识进行详细的讲解。
 在古代有个村子，这个村庄几乎与世隔绝，过着自给自足的生活，一开始村民进行交易的时候都会把这笔交易记录下来，当做凭证，但是村里的人不是个个都识字，所以这个时候就需要一个既识字有有威望的人来记账，刚好村长早些年读过书，而且他又是一村之长，自然就承担起了这个责任，村长每天的任务就是记录每一笔交易，比如张三使用100块买了王五家的猪，那么村长就在张三名下的存款减去100，在王五的账上加上100。
 故事讲到这就基本结束了，下面就是需要思考的时候了。上面讲的例子其实就是我们现实生活中银行干的事，所以你可以把村子看做是银行或者一个比较有权威的第三方支付平台如支付宝、微信。
 问题一、假如随着村长的年龄越来越大，眼睛跟脑子都不太好使了，记错账怎么办？
 我们可以让大家轮流来记账，这个月张三，下个月李四，大家轮着来，防止账本被一个人拿在手里。于是，账本的记账权发生变化，大家都有权来记账，而不再是单一个体来记账，这样就不怕别人记错账。
 问题二、如果这时候李四想要挪用村里的公款，虽然他不用直接篡改账本上的信息，但是可以烧掉账本中的一部分内容，这样别人就查不出来了，回头只要告诉大家这是不小心碰到蜡烛，别人也没什么办法。如何防止这种事情的发生？
 解决的办法是每个人都拥有一本自己的账本，任何一个人改动了账本都必须要告知所有其他人，其他人会在自己的账本上同样地记上一笔，如果有人发现新改动的账目不对，可以拒绝接受，到了最后，以大多数人都一致的账目表示为准。所以即便是有人真的不小心损坏了一部分账本的内容，只要找到其他的人去重新复制一份来就行了。
 问题三、如果时间长了，有人就偷懒了，不愿意这么麻烦地记账，就希望别人记好账后，自己拿过来核对一下，没问题就直接抄一遍，那么这下记账记得最勤的人就有意见了，该怎么办？
 办法是每天早上掷骰子，根据点数决定谁来记当天的账，其他人只要核对一下，没问题就复制过来。还可以让被掷到要记账的人，能获得一些奖励，从当天的记账总额中划出一定奖励的比例，这样记账的人就会积极的记账（这就是比特币的激励机制）。
讲到这里实际上这就是比特币的记账雏形，不过关于比特币还有很多细节没讲到，包括非对称加密、UTXO、SHA256算法、双花问题等等，这些后面再一一的讲解，现在先大概了解比特币的运行机制。比特币没有一个中心化的记账机构，记账权分散在各个节点中，使得它被篡改的几率大大降低，提高了安全性及可信任度，这是它的优点，但也是它的缺点，因为每记录一笔账就需要经过各个节点的确认，大大降低了运行效率。
 这里讲一下个人对于区块链的观点，区块链不是万能的，它在某些场景下确实具有无可比拟的优势，比如金融领域或者数据存储，但在某些场景下我们确实是需要中心化来管理的，所以个人觉得具体场景具体运用，均衡取舍，不要为了区块链而区块链，最后只会是得不偿失。未来的社会一定是中心化与去中心化并存，没有绝对的中心化也没有绝对的去中心化。
 </description>
    </item>
    
  </channel>
</rss>